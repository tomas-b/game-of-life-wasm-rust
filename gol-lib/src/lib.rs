extern crate wasm_bindgen;
use std::fmt;
use wasm_bindgen::prelude::*;

extern crate web_sys;
macro_rules! log {
    ( $( $t:tt )* ) => {
        web_sys::console::log_1(&format!( $( $t )* ).into());
    }
}

#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}

impl Cell {
    fn toggle(&mut self) {
        *self = match *self {
            Cell::Dead => Cell::Alive,
            Cell::Alive => Cell::Dead,
        };
    }
}

#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec<Cell>,
}

#[wasm_bindgen]
impl Universe {
    fn get_index(&self, row: u32, column: u32) -> usize {
        (row * self.width + column) as usize
    }

    fn live_neighbor_count(&self, row: u32, column: u32) -> u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 && delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }

    pub fn toggle_cell(&mut self, row: u32, column: u32) {
        let idx = self.get_index(row, column);
        self.cells[idx].toggle();
    }

    pub fn tick(&mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x < 2 => Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) => Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x > 3 => Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) => Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) => otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    pub fn new() -> Universe {
        let width = 100;
        let height = 80;
        log!("{}x{}", width, height);

        // let cells = (0..width * height)
        //     .map(|i| {
        //         if i % 2 == 0 || i % 7 == 0 {
        //             Cell::Alive
        //         } else {
        //             Cell::Dead
        //         }
        //     })
        //     .collect();

        // single glider
        let glider = vec![(1, 2), (2, 3), (3, 1), (3, 2), (3, 3)];
        let rustlogo = vec![ (26, 48), (26, 51), (26, 54), (27, 45), (27, 48), (27, 49), (27, 50), (27, 51), (27, 52), (27, 53), (27, 54), (27, 57), (28, 42), (28, 45), (28, 46), (28, 47), (28, 48), (28, 49), (28, 50), (28, 52), (28, 53), (28, 54), (28, 55), (28, 56), (28, 57), (28, 60), (29, 42), (29, 43), (29, 44), (29, 45), (29, 46), (29, 47), (29, 48), (29, 49), (29, 53), (29, 54), (29, 55), (29, 56), (29, 57), (29, 58), (29, 59), (29, 60), (30, 40), (30, 42), (30, 43), (30, 44), (30, 45), (30, 46), (30, 47), (30, 50), (30, 52), (30, 55), (30, 56), (30, 57), (30, 58), (30, 59), (30, 60), (30, 62), (31, 40), (31, 41), (31, 42), (31, 43), (31, 44), (31, 45), (31, 51), (31, 57), (31, 58), (31, 59), (31, 60), (31, 61), (31, 62), (32, 40), (32, 41), (32, 42), (32, 43), (32, 59), (32, 60), (32, 61), (32, 62), (33, 38), (33, 39), (33, 40), (33, 41), (33, 42), (33, 60), (33, 61), (33, 62), (33, 63), (33, 64), (34, 39), (34, 40), (34, 41), (34, 42), (34, 43), (34, 44), (34, 45), (34, 46), (34, 47), (34, 48), (34, 49), (34, 50), (34, 51), (34, 52), (34, 53), (34, 54), (34, 55), (34, 56), (34, 57), (34, 61), (34, 62), (34, 63), (35, 36), (35, 37), (35, 38), (35, 39), (35, 40), (35, 41), (35, 42), (35, 43), (35, 44), (35, 45), (35, 46), (35, 47), (35, 48), (35, 49), (35, 50), (35, 51), (35, 52), (35, 53), (35, 54), (35, 55), (35, 56), (35, 57), (35, 58), (35, 62), (35, 63), (35, 64), (35, 65), (36, 37), (36, 38), (36, 39), (36, 40), (36, 41), (36, 42), (36, 43), (36, 44), (36, 45), (36, 46), (36, 47), (36, 48), (36, 49), (36, 50), (36, 51), (36, 52), (36, 53), (36, 54), (36, 55), (36, 56), (36, 57), (36, 58), (36, 62), (36, 63), (36, 64), (36, 65), (37, 37), (37, 38), (37, 41), (37, 43), (37, 44), (37, 45), (37, 46), (37, 47), (37, 48), (37, 53), (37, 54), (37, 55), (37, 56), (37, 57), (37, 58), (37, 59), (37, 61), (37, 64), (37, 65), (38, 36), (38, 37), (38, 38), (38, 41), (38, 43), (38, 44), (38, 45), (38, 46), (38, 47), (38, 48), (38, 54), (38, 55), (38, 56), (38, 57), (38, 58), (38, 59), (38, 61), (38, 64), (38, 65), (38, 66), (39, 36), (39, 37), (39, 38), (39, 39), (39, 40), (39, 41), (39, 43), (39, 44), (39, 45), (39, 46), (39, 47), (39, 48), (39, 54), (39, 55), (39, 56), (39, 57), (39, 58), (39, 61), (39, 62), (39, 63), (39, 64), (39, 65), (39, 66), (39, 67), (40, 37), (40, 38), (40, 39), (40, 40), (40, 43), (40, 44), (40, 45), (40, 46), (40, 47), (40, 48), (40, 49), (40, 50), (40, 51), (40, 52), (40, 53), (40, 54), (40, 55), (40, 56), (40, 57), (40, 58), (40, 63), (40, 64), (40, 65), (41, 36), (41, 37), (41, 38), (41, 39), (41, 43), (41, 44), (41, 45), (41, 46), (41, 47), (41, 48), (41, 49), (41, 50), (41, 51), (41, 52), (41, 53), (41, 54), (41, 55), (41, 56), (41, 63), (41, 64), (41, 65), (41, 66), (42, 35), (42, 36), (42, 37), (42, 38), (42, 39), (42, 43), (42, 44), (42, 45), (42, 46), (42, 47), (42, 48), (42, 49), (42, 50), (42, 51), (42, 52), (42, 53), (42, 54), (42, 55), (42, 56), (42, 57), (42, 63), (42, 64), (42, 65), (42, 66), (42, 67), (43, 37), (43, 38), (43, 39), (43, 43), (43, 44), (43, 45), (43, 46), (43, 47), (43, 48), (43, 53), (43, 54), (43, 55), (43, 56), (43, 57), (43, 58), (43, 62), (43, 63), (43, 64), (43, 65), (44, 36), (44, 37), (44, 38), (44, 39), (44, 43), (44, 44), (44, 45), (44, 46), (44, 47), (44, 48), (44, 54), (44, 55), (44, 56), (44, 57), (44, 58), (44, 62), (44, 63), (44, 64), (44, 65), (44, 66), (45, 36), (45, 37), (45, 38), (45, 39), (45, 40), (45, 41), (45, 42), (45, 43), (45, 44), (45, 45), (45, 46), (45, 47), (45, 48), (45, 54), (45, 55), (45, 56), (45, 57), (45, 58), (45, 59), (45, 61), (45, 62), (45, 63), (45, 64), (45, 65), (45, 66), (45, 67), (46, 37), (46, 38), (46, 39), (46, 40), (46, 41), (46, 42), (46, 43), (46, 44), (46, 45), (46, 46), (46, 47), (46, 48), (46, 49), (46, 50), (46, 51), (46, 54), (46, 55), (46, 56), (46, 57), (46, 58), (46, 59), (46, 60), (46, 61), (46, 62), (46, 63), (46, 64), (46, 65), (47, 37), (47, 38), (47, 39), (47, 40), (47, 41), (47, 42), (47, 43), (47, 44), (47, 45), (47, 46), (47, 47), (47, 48), (47, 49), (47, 50), (47, 51), (47, 54), (47, 55), (47, 56), (47, 57), (47, 58), (47, 59), (47, 60), (47, 61), (47, 62), (47, 63), (47, 64), (47, 65), (48, 36), (48, 37), (48, 38), (48, 39), (48, 40), (48, 41), (48, 42), (48, 43), (48, 44), (48, 45), (48, 46), (48, 47), (48, 48), (48, 49), (48, 50), (48, 51), (48, 55), (48, 56), (48, 57), (48, 58), (48, 59), (48, 60), (48, 61), (48, 62), (48, 63), (48, 64), (48, 65), (48, 66), (49, 38), (49, 39), (49, 40), (49, 41), (49, 61), (49, 62), (49, 63), (50, 38), (50, 39), (50, 40), (50, 41), (50, 43), (50, 44), (50, 45), (50, 57), (50, 60), (50, 61), (50, 62), (50, 63), (50, 64), (51, 38), (51, 39), (51, 40), (51, 41), (51, 42), (51, 43), (51, 45), (51, 57), (51, 58), (51, 59), (51, 60), (51, 61), (51, 62), (51, 63), (51, 64), (52, 40), (52, 41), (52, 42), (52, 45), (52, 57), (52, 60), (52, 61), (52, 62), (53, 40), (53, 41), (53, 42), (53, 43), (53, 44), (53, 45), (53, 46), (53, 56), (53, 57), (53, 58), (53, 59), (53, 60), (53, 61), (53, 62), (54, 42), (54, 43), (54, 44), (54, 45), (54, 46), (54, 47), (54, 48), (54, 49), (54, 50), (54, 51), (54, 52), (54, 53), (54, 54), (54, 55), (54, 56), (54, 57), (54, 58), (54, 59), (54, 60), (55, 42), (55, 43), (55, 45), (55, 46), (55, 47), (55, 48), (55, 49), (55, 50), (55, 51), (55, 52), (55, 53), (55, 54), (55, 55), (55, 56), (55, 57), (55, 59), (55, 60), (56, 45), (56, 46), (56, 47), (56, 48), (56, 49), (56, 50), (56, 51), (56, 52), (56, 53), (56, 54), (56, 55), (56, 56), (56, 57), (57, 48), (57, 51), (57, 54), (58, 51), ]; 

        let mut cells: Vec<Cell> = (0..width * height).map(|_i| Cell::Dead).collect();

        for (row, col) in glider.iter().cloned() {
            let idx = (row * width + col) as usize;
            cells[idx] = Cell::Alive;
        }

        for (row, col) in rustlogo.iter().cloned() {
            let idx = (row * width + col) as usize;
            cells[idx] = Cell::Alive;
        }

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn set_width(&mut self, width: u32) {
        self.width = width;
        self.cells = (0..width * self.height).map(|_i| Cell::Dead).collect();
    }

    pub fn set_height(&mut self, height: u32) {
        self.height = height;
        self.cells = (0..self.width * height).map(|_i| Cell::Dead).collect();
    }

    pub fn render(&self) -> String {
        self.to_string()
    }

    pub fn width(&self) -> u32 {
        self.width
    }

    pub fn height(&self) -> u32 {
        self.height
    }

    pub fn cells(&self) -> *const Cell {
        self.cells.as_ptr()
    }
}

impl fmt::Display for Universe {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &cell in line {
                let symbol = if cell == Cell::Dead { '◻' } else { '◼' };
                write!(f, "{}", symbol)?;
            }
            write!(f, "\n")?;
        }

        Ok(())
    }
}
